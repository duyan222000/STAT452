scale_y_continuous("Y (grid)", breaks = 2:9, limits = c(1.5, 9.5), expand = c(0,0)) +
coord_fixed() +
scale_fill_viridis_c(
name = "Area (ha)", option = "magma", direction = -1,
breaks = breaks_area, labels = label_number(accuracy = 1)
) +
scale_size_continuous(
name = "Area (ha)", range = c(1.5, 10),
breaks = breaks_area, labels = label_number(accuracy = 1)
) +
guides(
fill = guide_colorbar(barheight = unit(70, "pt"), barwidth = unit(8, "pt")),
size = guide_legend(override.aes = list(fill = "grey60"))
) +
labs(title = "Spatial distribution of fires in Montesinho Park") +
theme_minimal(base_size = 14) +
theme(
panel.grid.minor = element_blank(),
panel.grid.major = element_line(colour = "grey85"),
plot.title = element_text(face = "bold", hjust = 0, size = 16),
legend.title = element_text(size = 11),
legend.text  = element_text(size = 10),
legend.key.height = unit(10, "pt")
)
print(p_spatial)
ggsave("plots/fig_spatial_distribution.png", p_spatial, width = 8.5, height = 6.5, dpi = 300)
# ==== EDA basics (unchanged visuals but consistent styling) ====
# Raw & log distributions
p_hist_raw <- ggplot(forest, aes(area)) +
geom_histogram(bins = 50, fill = "#4C78A8") +
labs(title = "Distribution of Burned Area (raw)", x = "Area (ha)", y = "Count") +
theme_minimal(base_size = 13)
ggsave("plots/fig_hist_area_raw.png", p_hist_raw, width = 7.2, height = 5, dpi = 300)
p_hist_log <- ggplot(forest, aes(log_area)) +
geom_histogram(bins = 50, fill = "#72B7B2") +
labs(title = "Distribution of Burned Area (log scale)", x = "log(1 + Area)", y = "Count") +
theme_minimal(base_size = 13)
ggsave("plots/fig_hist_area_log.png", p_hist_log, width = 7.2, height = 5, dpi = 300)
# Boxplots by month/day
p_box_month <- ggplot(forest, aes(month, log_area)) +
geom_boxplot(outlier.alpha = 0.45, fill = "#E45756") +
labs(title = "Burned Area (log scale) by Month", x = "Month", y = "log(1 + Area)") +
theme_minimal(base_size = 13)
ggsave("plots/fig_box_month.png", p_box_month, width = 8, height = 4.8, dpi = 300)
p_box_day <- ggplot(forest, aes(day, log_area)) +
geom_boxplot(outlier.alpha = 0.45, fill = "#F1A208") +
labs(title = "Burned Area (log scale) by Day of Week", x = "Day of Week", y = "log(1 + Area)") +
theme_minimal(base_size = 13)
ggsave("plots/fig_box_day.png", p_box_day, width = 7.2, height = 4.8, dpi = 300)
# Correlation (numeric only)
num_df <- forest %>% select(where(is.numeric))
corr_mat <- cor(num_df, method = "spearman", use = "pairwise.complete.obs")
png("plots/fig_corr_heatmap.png", width = 2000, height = 1600, res = 220)
corrplot::corrplot(corr_mat, type = "upper", order = "hclust",
tl.cex = 0.7, tl.col = "black", tl.srt = 45,
mar = c(0,0,2,0), main = "Spearman Correlations")
dev.off()
# ==== Influence cleanup (Cook’s distance) ====
# Fit a *proper* baseline (no leakage) for influence:
lm0 <- lm(log_area ~ X + Y + month + day + FFMC + DMC + DC + ISI + temp + RH + wind + rain, data = forest)
cooks <- cooks.distance(lm0)
cooks[!is.finite(cooks)] <- NA_real_   # guard
thr <- 4/length(cooks)
ymax <- safe_max(cooks) * 1.08
png("plots/fig_cooks.png", width = 1600, height = 900, res = 220)
plot(cooks, type = "h",
ylim = c(0, ymax),
main = "Cook's Distance for Influential Observations",
ylab = "Cook's Distance", xlab = "Index")
abline(h = thr, col = "red", lty = 2)
dev.off()
influential <- which(is.finite(cooks) & cooks > thr)
forest_clean <- if (length(influential)) forest[-influential, ] else forest
# ==== REGRESSION: Ridge / LASSO / Elastic Net (leakage fixed) ====
split <- trainTestSplit(forest_clean, seed = 0, trainRatio = 0.8)
tr <- split$train; te <- split$test
# Model matrices — critically exclude *both* area and log_area from X
mm_formula <- ~ . - area - log_area
mm_all <- model.matrix(mm_formula, data = rbind(tr, te))
n_tr   <- nrow(tr)
x_all  <- mm_all[, -1, drop = FALSE]
x_tr   <- x_all[1:n_tr, , drop = FALSE]
x_te   <- x_all[(n_tr+1):nrow(x_all), , drop = FALSE]
y_tr   <- tr$log_area
y_te   <- te$log_area
set.seed(123)
cv.ridge   <- cv.glmnet(x_tr, y_tr, alpha = 0,  standardize = TRUE)
cv.lasso   <- cv.glmnet(x_tr, y_tr, alpha = 1,  standardize = TRUE)
cv.elastic <- cv.glmnet(x_tr, y_tr, alpha = 0.5,standardize = TRUE)
ridge.model   <- glmnet(x_tr, y_tr, alpha = 0,   lambda = cv.ridge$lambda.min)
lasso.model   <- glmnet(x_tr, y_tr, alpha = 1,   lambda = cv.lasso$lambda.min)
elastic.model <- glmnet(x_tr, y_tr, alpha = 0.5, lambda = cv.elastic$lambda.min)
# Save CV plots for the report
png("plots/fig_cv_ridge.png", width = 1400, height = 1000, res = 220);  plot(cv.ridge);   title("Ridge CV", line = 2.5);   dev.off()
png("plots/fig_cv_lasso.png", width = 1400, height = 1000, res = 220);  plot(cv.lasso);   title("LASSO CV", line = 2.5);   dev.off()
png("plots/fig_cv_elnet.png", width = 1400, height = 1000, res = 220);  plot(cv.elastic); title("Elastic Net CV", line = 2.5); dev.off()
# Predictions + metrics
pr_lasso   <- as.numeric(predict(lasso.model,   newx = x_te))
pr_ridge   <- as.numeric(predict(ridge.model,   newx = x_te))
pr_elastic <- as.numeric(predict(elastic.model, newx = x_te))
res_tbl <- rbind(
LASSO   = metrics(y_te, pr_lasso),
RIDGE   = metrics(y_te, pr_ridge),
ELASTIC = metrics(y_te, pr_elastic)
) %>% as.data.frame() %>% rownames_to_column("Model")
gt(res_tbl %>% mutate(across(-Model, ~round(., 4)))) %>%
tab_header(title = md("**Predictive performance (test set)**")) %>%
fmt_number(columns = c(RMSE, MAE, R2), decimals = 4) %>%
gtsave("plots/table_regression_metrics.png")
# ==== Packages ====
# install.packages(c("tidyverse","glmnet","corrplot","pROC","viridis","gt","broom","scales","kableExtra"))
library(tidyverse)
library(glmnet)
library(corrplot)
library(pROC)
library(viridis)
library(gt)
library(broom)
library(scales)
library(kableExtra)
safe_max <- function(x) {
m <- suppressWarnings(max(x, na.rm = TRUE))
if (!is.finite(m) || m <= 0) 1 else m
}
# ==== IO / helpers ====
dir.create("plots", showWarnings = FALSE)
readr::local_edition(1)
metrics <- function(y, yhat){
rmse <- sqrt(mean((y - yhat)^2))
mae  <- mean(abs(y - yhat))
r2   <- 1 - sum((y - yhat)^2)/sum((y - mean(y))^2)
c(RMSE = rmse, MAE = mae, R2 = r2)
}
trainTestSplit <- function(data, seed = 0, trainRatio = 0.8){
set.seed(seed)
n  <- nrow(data)
tr <- sample(seq_len(n), size = round(trainRatio*n), replace = FALSE)
list(train = data[tr, , drop = FALSE], test = data[-tr, , drop = FALSE])
}
# ==== Load data ====
forest <- read.csv("data/ForestFire.csv", stringsAsFactors = FALSE)
# Transform & factors (match ordering used in report)
forest <- forest %>%
mutate(
log_area = log1p(area),
month = factor(month, levels = c("jan","feb","mar","apr","may","jun","jul","aug","sep","oct","nov","dec")),
day   = factor(day,   levels = c("mon","tue","wed","thu","fri","sat","sun"))
)
# ==== Spatial distribution (improved) ====
# - light jitter so overlapping points separate
# - outlined filled circles, size & fill = area
# - equal aspect ratio, fine grid, consistent legend styling
breaks_area <- c(0, 50, 250, 500, 1000)
p_spatial <- ggplot(forest, aes(X, Y)) +
geom_point(
aes(size = area, fill = area),
shape = 21, colour = "grey15", alpha = 0.9,
position = position_jitter(width = 0.10, height = 0.10)
) +
scale_x_continuous("X (grid)", breaks = 1:9, limits = c(0.5, 9.5), expand = c(0,0)) +
scale_y_continuous("Y (grid)", breaks = 2:9, limits = c(1.5, 9.5), expand = c(0,0)) +
coord_fixed() +
scale_fill_viridis_c(
name = "Area (ha)", option = "magma", direction = -1,
breaks = breaks_area, labels = label_number(accuracy = 1)
) +
scale_size_continuous(
name = "Area (ha)", range = c(1.5, 10),
breaks = breaks_area, labels = label_number(accuracy = 1)
) +
guides(
fill = guide_colorbar(barheight = unit(70, "pt"), barwidth = unit(8, "pt")),
size = guide_legend(override.aes = list(fill = "grey60"))
) +
labs(title = "Spatial distribution of fires in Montesinho Park") +
theme_minimal(base_size = 14) +
theme(
panel.grid.minor = element_blank(),
panel.grid.major = element_line(colour = "grey85"),
plot.title = element_text(face = "bold", hjust = 0, size = 16),
legend.title = element_text(size = 11),
legend.text  = element_text(size = 10),
legend.key.height = unit(10, "pt")
)
print(p_spatial)
ggsave("plots/fig_spatial_distribution.png", p_spatial, width = 8.5, height = 6.5, dpi = 300)
# ==== EDA basics (unchanged visuals but consistent styling) ====
# Raw & log distributions
p_hist_raw <- ggplot(forest, aes(area)) +
geom_histogram(bins = 50, fill = "#4C78A8") +
labs(title = "Distribution of Burned Area (raw)", x = "Area (ha)", y = "Count") +
theme_minimal(base_size = 13)
ggsave("plots/fig_hist_area_raw.png", p_hist_raw, width = 7.2, height = 5, dpi = 300)
p_hist_log <- ggplot(forest, aes(log_area)) +
geom_histogram(bins = 50, fill = "#72B7B2") +
labs(title = "Distribution of Burned Area (log scale)", x = "log(1 + Area)", y = "Count") +
theme_minimal(base_size = 13)
ggsave("plots/fig_hist_area_log.png", p_hist_log, width = 7.2, height = 5, dpi = 300)
# Boxplots by month/day
p_box_month <- ggplot(forest, aes(month, log_area)) +
geom_boxplot(outlier.alpha = 0.45, fill = "#E45756") +
labs(title = "Burned Area (log scale) by Month", x = "Month", y = "log(1 + Area)") +
theme_minimal(base_size = 13)
ggsave("plots/fig_box_month.png", p_box_month, width = 8, height = 4.8, dpi = 300)
p_box_day <- ggplot(forest, aes(day, log_area)) +
geom_boxplot(outlier.alpha = 0.45, fill = "#F1A208") +
labs(title = "Burned Area (log scale) by Day of Week", x = "Day of Week", y = "log(1 + Area)") +
theme_minimal(base_size = 13)
ggsave("plots/fig_box_day.png", p_box_day, width = 7.2, height = 4.8, dpi = 300)
# Correlation (numeric only)
num_df <- forest %>% select(where(is.numeric))
corr_mat <- cor(num_df, method = "spearman", use = "pairwise.complete.obs")
png("plots/fig_corr_heatmap.png", width = 2000, height = 1600, res = 220)
corrplot::corrplot(corr_mat, type = "upper", order = "hclust",
tl.cex = 0.7, tl.col = "black", tl.srt = 45,
mar = c(0,0,2,0), main = "Spearman Correlations")
dev.off()
# ==== Influence cleanup (Cook’s distance) ====
# Fit a *proper* baseline (no leakage) for influence:
lm0 <- lm(log_area ~ X + Y + month + day + FFMC + DMC + DC + ISI + temp + RH + wind + rain, data = forest)
cooks <- cooks.distance(lm0)
cooks[!is.finite(cooks)] <- NA_real_   # guard
thr <- 4/length(cooks)
ymax <- safe_max(cooks) * 1.08
png("plots/fig_cooks.png", width = 1600, height = 900, res = 220)
plot(cooks, type = "h",
ylim = c(0, ymax),
main = "Cook's Distance for Influential Observations",
ylab = "Cook's Distance", xlab = "Index")
abline(h = thr, col = "red", lty = 2)
dev.off()
influential <- which(is.finite(cooks) & cooks > thr)
forest_clean <- if (length(influential)) forest[-influential, ] else forest
# ==== REGRESSION: Ridge / LASSO / Elastic Net (leakage fixed) ====
split <- trainTestSplit(forest_clean, seed = 0, trainRatio = 0.8)
tr <- split$train; te <- split$test
# Model matrices — critically exclude *both* area and log_area from X
mm_formula <- ~ . - area - log_area
mm_all <- model.matrix(mm_formula, data = rbind(tr, te))
n_tr   <- nrow(tr)
x_all  <- mm_all[, -1, drop = FALSE]
x_tr   <- x_all[1:n_tr, , drop = FALSE]
x_te   <- x_all[(n_tr+1):nrow(x_all), , drop = FALSE]
y_tr   <- tr$log_area
y_te   <- te$log_area
set.seed(123)
cv.ridge   <- cv.glmnet(x_tr, y_tr, alpha = 0,  standardize = TRUE)
cv.lasso   <- cv.glmnet(x_tr, y_tr, alpha = 1,  standardize = TRUE)
cv.elastic <- cv.glmnet(x_tr, y_tr, alpha = 0.5,standardize = TRUE)
ridge.model   <- glmnet(x_tr, y_tr, alpha = 0,   lambda = cv.ridge$lambda.min)
lasso.model   <- glmnet(x_tr, y_tr, alpha = 1,   lambda = cv.lasso$lambda.min)
elastic.model <- glmnet(x_tr, y_tr, alpha = 0.5, lambda = cv.elastic$lambda.min)
# Save CV plots for the report
png("plots/fig_cv_ridge.png", width = 1400, height = 1000, res = 220);  plot(cv.ridge);   title("Ridge CV", line = 2.5);   dev.off()
png("plots/fig_cv_lasso.png", width = 1400, height = 1000, res = 220);  plot(cv.lasso);   title("LASSO CV", line = 2.5);   dev.off()
png("plots/fig_cv_elnet.png", width = 1400, height = 1000, res = 220);  plot(cv.elastic); title("Elastic Net CV", line = 2.5); dev.off()
# Predictions + metrics
pr_lasso   <- as.numeric(predict(lasso.model,   newx = x_te))
pr_ridge   <- as.numeric(predict(ridge.model,   newx = x_te))
pr_elastic <- as.numeric(predict(elastic.model, newx = x_te))
res_tbl <- rbind(
LASSO   = metrics(y_te, pr_lasso),
RIDGE   = metrics(y_te, pr_ridge),
ELASTIC = metrics(y_te, pr_elastic)
) %>% as.data.frame() %>% rownames_to_column("Model")
gt(res_tbl %>% mutate(across(-Model, ~round(., 4)))) %>%
tab_header(title = md("**Predictive performance (test set)**")) %>%
fmt_number(columns = c(RMSE, MAE, R2), decimals = 4) %>%
gtsave("plots/table_regression_metrics.png")
message("All figures/tables saved in the 'plots/' folder:
- fig_spatial_distribution.png   (use this to replace the spatial figure)
- fig_hist_area_raw.png, fig_hist_area_log.png
- fig_box_month.png, fig_box_day.png, fig_corr_heatmap.png, fig_cooks.png
- fig_cv_ridge.png, fig_cv_lasso.png, fig_cv_elnet.png
- table_regression_metrics.png, fig_residuals_lasso.png
- fig_recall_threshold.png, fig_roc.png
- table_confusion_matrix.png, table_classification_metrics.png")
# =========================
# Forest Fires: Full Script
# =========================
# ---- Packages ----
# install.packages(c("tidyverse","glmnet","corrplot","pROC","viridis","gt","gridExtra","broom","scales","kableExtra"))
library(tidyverse)
library(glmnet)
library(corrplot)
library(pROC)
library(viridis)
library(gt)
library(gridExtra)
library(broom)
library(scales)
library(kableExtra)
library(grid)   # for unit()
set.seed(123)
dir.create("plots", showWarnings = FALSE)
# ---- Safe helpers ----
safe_max <- function(x) {
m <- suppressWarnings(max(x, na.rm = TRUE))
if (!is.finite(m) || m <= 0) 1 else m
}
# Save a small data.frame as a PNG table (fallback when gt can't save)
png_table <- function(df, file, width=900, height=360, res=160, rows=NULL) {
tbl <- gridExtra::tableGrob(df, rows = rows)
png(file, width = width, height = height, res = res); grid::grid.draw(tbl); dev.off()
}
# Try gt::gtsave then fallback to png_table
save_table <- function(df, file, caption = NULL, width=900, height=360, res=160) {
out <- try({
gt(df) %>%
{if (!is.null(caption)) tab_header(., title = md(paste0("**", caption, "**"))) else .} %>%
gtsave(file)
}, silent = TRUE)
if (inherits(out, "try-error")) {
png_table(df, file, width, height, res)
}
}
metrics <- function(y, yhat){
rmse <- sqrt(mean((y - yhat)^2))
mae  <- mean(abs(y - yhat))
r2   <- 1 - sum((y - yhat)^2)/sum((y - mean(y))^2)
c(RMSE = rmse, MAE = mae, R2 = r2)
}
trainTestSplit <- function(data, seed = 0, trainRatio = 0.8){
set.seed(seed)
n  <- nrow(data)
tr <- sample(seq_len(n), size = round(trainRatio*n), replace = FALSE)
list(train = data[tr, , drop = FALSE], test = data[-tr, , drop = FALSE])
}
# Stratified split for classification
stratified_split <- function(df, target_col = "target", train_ratio=.8, seed=123){
set.seed(seed)
i1 <- which(df[[target_col]]==1); i0 <- which(df[[target_col]]==0)
n1 <- round(train_ratio*length(i1)); n0 <- round(train_ratio*length(i0))
tr_idx <- c(sample(i1, n1), sample(i0, n0))
te_idx <- setdiff(seq_len(nrow(df)), tr_idx)
list(train=df[tr_idx, , drop=FALSE], test=df[te_idx, , drop=FALSE])
}
# ---- Load data ----
forest <- read.csv("data/ForestFire.csv", stringsAsFactors = FALSE)
forest <- forest %>%
mutate(
log_area = log1p(area),
month = factor(month, levels = c("jan","feb","mar","apr","may","jun","jul","aug","sep","oct","nov","dec")),
day   = factor(day,   levels = c("mon","tue","wed","thu","fri","sat","sun")),
target = as.integer(area > 0)
)
# ==============
# EDA & Plots
# ==============
# Spatial distribution (friend-style): jitter, outlined points, viridis fill, equal aspect
breaks_area <- c(0, 50, 250, 500, 1000)
p_spatial <- ggplot(forest, aes(X, Y)) +
geom_point(
aes(size = area, fill = area),
shape = 21, colour = "grey15", alpha = 0.9,
position = position_jitter(width = 0.10, height = 0.10)
) +
scale_x_continuous("X (grid)", breaks = 1:9, limits = c(0.5, 9.5), expand = c(0,0)) +
scale_y_continuous("Y (grid)", breaks = 2:9, limits = c(1.5, 9.5), expand = c(0,0)) +
coord_fixed() +
scale_fill_viridis_c(
name = "Area (ha)", option = "magma", direction = -1,
breaks = breaks_area, labels = label_number(accuracy = 1)
) +
scale_size_continuous(
name = "Area (ha)", range = c(1.5, 10),
breaks = breaks_area, labels = label_number(accuracy = 1)
) +
guides(
fill = guide_colorbar(barheight = grid::unit(70, "pt"), barwidth = grid::unit(8, "pt")),
size = guide_legend(override.aes = list(fill = "grey60"))
) +
labs(title = "Spatial distribution of fires in Montesinho Park") +
theme_minimal(base_size = 14) +
theme(
panel.grid.minor = element_blank(),
panel.grid.major = element_line(colour = "grey85"),
plot.title = element_text(face = "bold", hjust = 0, size = 16),
legend.title = element_text(size = 11),
legend.text  = element_text(size = 10),
legend.key.height = grid::unit(10, "pt")
)
ggsave("plots/fig_spatial_distribution.png", p_spatial, width = 8.5, height = 6.5, dpi = 300)
# Histograms (raw / log)
p_hist_raw <- ggplot(forest, aes(area)) +
geom_histogram(bins = 50, fill = "#4C78A8") +
labs(title = "Distribution of Burned Area (raw)", x = "Area (ha)", y = "Count") +
theme_minimal(base_size = 13)
ggsave("plots/fig_hist_area_raw.png", p_hist_raw, width = 7.2, height = 5, dpi = 300)
p_hist_log <- ggplot(forest, aes(log_area)) +
geom_histogram(bins = 50, fill = "#72B7B2") +
labs(title = "Distribution of Burned Area (log scale)", x = "log(1 + Area)", y = "Count") +
theme_minimal(base_size = 13)
ggsave("plots/fig_hist_area_log.png", p_hist_log, width = 7.2, height = 5, dpi = 300)
# Boxplots by month/day
p_box_month <- ggplot(forest, aes(month, log_area)) +
geom_boxplot(outlier.alpha = 0.45, fill = "#E45756") +
labs(title = "Burned Area (log scale) by Month", x = "Month", y = "log(1 + Area)") +
theme_minimal(base_size = 13)
ggsave("plots/fig_box_month.png", p_box_month, width = 8, height = 4.8, dpi = 300)
p_box_day <- ggplot(forest, aes(day, log_area)) +
geom_boxplot(outlier.alpha = 0.45, fill = "#F1A208") +
labs(title = "Burned Area (log scale) by Day of Week", x = "Day of Week", y = "log(1 + Area)") +
theme_minimal(base_size = 13)
ggsave("plots/fig_box_day.png", p_box_day, width = 7.2, height = 4.8, dpi = 300)
# Correlation heatmap (numeric only)
num_df  <- forest %>% select(where(is.numeric))
corr_mat <- cor(num_df, method = "spearman", use = "pairwise.complete.obs")
png("plots/fig_corr_heatmap.png", width = 2000, height = 1600, res = 220)
corrplot::corrplot(corr_mat, type = "upper", order = "hclust",
tl.cex = 0.7, tl.col = "black", tl.srt = 45,
mar = c(0,0,2,0), main = "Spearman Correlations")
dev.off()
# ===============
# IQR Cleaning
# ===============
iqr_trim <- function(x) {
q1 <- quantile(x, .25, na.rm=TRUE); q3 <- quantile(x, .75, na.rm=TRUE)
i  <- IQR(x, na.rm=TRUE); lo <- q1 - 1.5*i; hi <- q3 + 1.5*i
x >= lo & x <= hi
}
num_cols <- names(select(forest, where(is.numeric)))
keep_mask <- Reduce(`&`, lapply(forest[num_cols], iqr_trim))
forest_iqr <- forest[keep_mask, , drop=FALSE]
cat("IQR removed rows: ", nrow(forest) - nrow(forest_iqr), "/", nrow(forest), "\n", sep="")
# Drop 'rain' if constant after IQR (common)
if ("rain" %in% names(forest_iqr) && length(unique(forest_iqr$rain)) <= 1) {
forest_iqr$rain <- NULL
cat("Dropped 'rain' (constant after IQR cleaning)\n")
}
# BEFORE/AFTER boxplots
forest %>%
select(where(is.numeric)) %>%
pivot_longer(everything()) %>%
ggplot(aes(name, value)) +
geom_boxplot(outlier.alpha=.2) + coord_flip() +
labs(title="Numeric variables BEFORE IQR cleaning", x=NULL, y=NULL) +
theme_minimal(base_size = 12) -> p_before
ggsave("plots/fig_box_before_iqr.png", p_before, width=7.5, height=6, dpi=300)
forest_iqr %>%
select(where(is.numeric)) %>%
pivot_longer(everything()) %>%
ggplot(aes(name, value)) +
geom_boxplot(outlier.alpha=.2) + coord_flip() +
labs(title="Numeric variables AFTER IQR cleaning", x=NULL, y=NULL) +
theme_minimal(base_size = 12) -> p_after
ggsave("plots/fig_box_after_iqr.png", p_after, width=7.5, height=6, dpi=300)
# Bivariate panels (after IQR)
num_vars <- intersect(c("FFMC","DMC","DC","ISI","temp","RH","wind","X","Y"), names(forest_iqr))
forest_iqr %>%
pivot_longer(all_of(num_vars), names_to="var", values_to="value") %>%
ggplot(aes(value, log_area)) +
geom_point(alpha=.25) +
geom_smooth(method="lm", se=FALSE) +
facet_wrap(~var, scales="free_x") +
labs(title="log(1+area) vs predictors (after IQR cleaning)") +
theme_minimal(base_size = 12) -> p_bivar
ggsave("plots/fig_bivariate_panels.png", p_bivar, width=9, height=6.5, dpi=300)
# ==========================
# Cook's distance (safe)
# ==========================
lm0 <- lm(log_area ~ . - target, data = forest_iqr)
cooks <- cooks.distance(lm0); cooks[!is.finite(cooks)] <- NA_real_
thr <- 4/length(cooks); ymax <- safe_max(cooks) * 1.08
png("plots/fig_cooks.png", width = 1600, height = 900, res = 220)
plot(cooks, type = "h",
ylim = c(0, ymax),
main = "Cook's Distance for Influential Observations",
ylab = "Cook's Distance", xlab = "Index")
abline(h = thr, col = "red", lty = 2)
dev.off()
influential <- which(is.finite(cooks) & cooks > thr)
forest_final <- if (length(influential)) forest_iqr[-influential, , drop=FALSE] else forest_iqr
cat("Cook's removed: ", length(influential), " rows\n", sep="")
# ==========================
# REGRESSION (glmnet)
# ==========================
split_r <- trainTestSplit(forest_final, seed = 0, trainRatio = 0.8)
tr_r <- split_r$train; te_r <- split_r$test
# Design matrix WITHOUT area & log_area & target (no leakage)
mm_reg <- model.matrix(~ . - area - log_area - target, data = rbind(tr_r, te_r))
ntr <- nrow(tr_r)
x_tr <- mm_reg[1:ntr, -1, drop=FALSE]
x_te <- mm_reg[(ntr+1):nrow(mm_reg), -1, drop=FALSE]
y_tr <- tr_r$log_area
y_te <- te_r$log_area
set.seed(123)
cv.ridge <- cv.glmnet(x_tr, y_tr, alpha=0,   standardize=TRUE)
cv.lasso <- cv.glmnet(x_tr, y_tr, alpha=1,   standardize=TRUE)
# small alpha grid for EN
alpha_grid <- seq(0.1, 0.9, by=0.2)
cv_list <- lapply(alpha_grid, function(a) cv.glmnet(x_tr, y_tr, alpha=a, standardize=TRUE))
best_en_idx <- which.min(sapply(cv_list, \(cv) min(cv$cvm)))
best_alpha <- alpha_grid[best_en_idx]; cv.elastic <- cv_list[[best_en_idx]]
ridge.model   <- glmnet(x_tr, y_tr, alpha=0,   lambda=cv.ridge$lambda.min, standardize=TRUE)
lasso.model   <- glmnet(x_tr, y_tr, alpha=1,   lambda=cv.lasso$lambda.min, standardize=TRUE)
elastic.model <- glmnet(x_tr, y_tr, alpha=best_alpha, lambda=cv.elastic$lambda.min, standardize=TRUE)
# Save CV plots
png("plots/fig_cv_ridge.png", width = 1400, height = 1000, res = 220);  plot(cv.ridge);   title("Ridge CV",   line = 2.5); dev.off()
png("plots/fig_cv_lasso.png", width = 1400, height = 1000, res = 220);  plot(cv.lasso);   title("LASSO CV",   line = 2.5); dev.off()
png("plots/fig_cv_elnet.png", width = 1400, height = 1000, res = 220);  plot(cv.elastic); title(paste0("Elastic Net CV (alpha=",best_alpha,")"), line = 2.5); dev.off()
# Predictions + metrics (test)
pred_ridge   <- as.numeric(predict(ridge.model,   newx=x_te))
pred_lasso   <- as.numeric(predict(lasso.model,   newx=x_te))
pred_elastic <- as.numeric(predict(elastic.model, newx=x_te))
res_reg <- rbind(
RIDGE   = metrics(y_te, pred_ridge),
LASSO   = metrics(y_te, pred_lasso),
ELASTIC = metrics(y_te, pred_elastic)
) %>% as.data.frame() %>% rownames_to_column("Model") %>%
mutate(across(-Model, ~round(., 4)))
save_table(res_reg, "plots/table_regression_metrics.png", caption = "Predictive performance (test set)")
